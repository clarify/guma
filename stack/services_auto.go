// Code generated by opcua-xml2code. DO NOT EDIT.

package stack

import (
	"bytes"
	"fmt"
	"time"

	"github.com/searis/guma/stack/encoding/binary"
	"github.com/searis/guma/stack/transport"
	"github.com/searis/guma/stack/uatype"
)

// CreateSession sends a CreateSession request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) CreateSession(req uatype.CreateSessionRequest, deadline time.Time) (*uatype.CreateSessionResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdCreateSessionRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdCreateSessionResponse_Encoding_DefaultBinary:
		res := &uatype.CreateSessionResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// ActivateSession sends a ActivateSession request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) ActivateSession(req uatype.ActivateSessionRequest, deadline time.Time) (*uatype.ActivateSessionResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdActivateSessionRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdActivateSessionResponse_Encoding_DefaultBinary:
		res := &uatype.ActivateSessionResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// CloseSession sends a CloseSession request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) CloseSession(req uatype.CloseSessionRequest, deadline time.Time) (*uatype.CloseSessionResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdCloseSessionRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdCloseSessionResponse_Encoding_DefaultBinary:
		res := &uatype.CloseSessionResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// Cancel sends a Cancel request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) Cancel(req uatype.CancelRequest, deadline time.Time) (*uatype.CancelResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdCancelRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdCancelResponse_Encoding_DefaultBinary:
		res := &uatype.CancelResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// AddNodes sends a AddNodes request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) AddNodes(req uatype.AddNodesRequest, deadline time.Time) (*uatype.AddNodesResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdAddNodesRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdAddNodesResponse_Encoding_DefaultBinary:
		res := &uatype.AddNodesResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// AddReferences sends a AddReferences request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) AddReferences(req uatype.AddReferencesRequest, deadline time.Time) (*uatype.AddReferencesResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdAddReferencesRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdAddReferencesResponse_Encoding_DefaultBinary:
		res := &uatype.AddReferencesResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// DeleteNodes sends a DeleteNodes request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) DeleteNodes(req uatype.DeleteNodesRequest, deadline time.Time) (*uatype.DeleteNodesResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdDeleteNodesRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdDeleteNodesResponse_Encoding_DefaultBinary:
		res := &uatype.DeleteNodesResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// DeleteReferences sends a DeleteReferences request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) DeleteReferences(req uatype.DeleteReferencesRequest, deadline time.Time) (*uatype.DeleteReferencesResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdDeleteReferencesRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdDeleteReferencesResponse_Encoding_DefaultBinary:
		res := &uatype.DeleteReferencesResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// Browse sends a Browse request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) Browse(req uatype.BrowseRequest, deadline time.Time) (*uatype.BrowseResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdBrowseRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdBrowseResponse_Encoding_DefaultBinary:
		res := &uatype.BrowseResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// BrowseNext sends a BrowseNext request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) BrowseNext(req uatype.BrowseNextRequest, deadline time.Time) (*uatype.BrowseNextResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdBrowseNextRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdBrowseNextResponse_Encoding_DefaultBinary:
		res := &uatype.BrowseNextResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// TranslateBrowsePathsToNodeIds sends a TranslateBrowsePathsToNodeIds request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) TranslateBrowsePathsToNodeIds(req uatype.TranslateBrowsePathsToNodeIdsRequest, deadline time.Time) (*uatype.TranslateBrowsePathsToNodeIdsResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdTranslateBrowsePathsToNodeIdsRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdTranslateBrowsePathsToNodeIdsResponse_Encoding_DefaultBinary:
		res := &uatype.TranslateBrowsePathsToNodeIdsResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// RegisterNodes sends a RegisterNodes request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) RegisterNodes(req uatype.RegisterNodesRequest, deadline time.Time) (*uatype.RegisterNodesResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdRegisterNodesRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdRegisterNodesResponse_Encoding_DefaultBinary:
		res := &uatype.RegisterNodesResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// UnregisterNodes sends a UnregisterNodes request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) UnregisterNodes(req uatype.UnregisterNodesRequest, deadline time.Time) (*uatype.UnregisterNodesResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdUnregisterNodesRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdUnregisterNodesResponse_Encoding_DefaultBinary:
		res := &uatype.UnregisterNodesResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// QueryFirst sends a QueryFirst request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) QueryFirst(req uatype.QueryFirstRequest, deadline time.Time) (*uatype.QueryFirstResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdQueryFirstRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdQueryFirstResponse_Encoding_DefaultBinary:
		res := &uatype.QueryFirstResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// QueryNext sends a QueryNext request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) QueryNext(req uatype.QueryNextRequest, deadline time.Time) (*uatype.QueryNextResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdQueryNextRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdQueryNextResponse_Encoding_DefaultBinary:
		res := &uatype.QueryNextResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// Read sends a Read request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) Read(req uatype.ReadRequest, deadline time.Time) (*uatype.ReadResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdReadRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdReadResponse_Encoding_DefaultBinary:
		res := &uatype.ReadResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// HistoryRead sends a HistoryRead request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) HistoryRead(req uatype.HistoryReadRequest, deadline time.Time) (*uatype.HistoryReadResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdHistoryReadRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdHistoryReadResponse_Encoding_DefaultBinary:
		res := &uatype.HistoryReadResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// Write sends a Write request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) Write(req uatype.WriteRequest, deadline time.Time) (*uatype.WriteResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdWriteRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdWriteResponse_Encoding_DefaultBinary:
		res := &uatype.WriteResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// HistoryUpdate sends a HistoryUpdate request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) HistoryUpdate(req uatype.HistoryUpdateRequest, deadline time.Time) (*uatype.HistoryUpdateResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdHistoryUpdateRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdHistoryUpdateResponse_Encoding_DefaultBinary:
		res := &uatype.HistoryUpdateResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// Call sends a Call request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) Call(req uatype.CallRequest, deadline time.Time) (*uatype.CallResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdCallRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdCallResponse_Encoding_DefaultBinary:
		res := &uatype.CallResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// CreateMonitoredItems sends a CreateMonitoredItems request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) CreateMonitoredItems(req uatype.CreateMonitoredItemsRequest, deadline time.Time) (*uatype.CreateMonitoredItemsResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdCreateMonitoredItemsRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdCreateMonitoredItemsResponse_Encoding_DefaultBinary:
		res := &uatype.CreateMonitoredItemsResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// ModifyMonitoredItems sends a ModifyMonitoredItems request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) ModifyMonitoredItems(req uatype.ModifyMonitoredItemsRequest, deadline time.Time) (*uatype.ModifyMonitoredItemsResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdModifyMonitoredItemsRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdModifyMonitoredItemsResponse_Encoding_DefaultBinary:
		res := &uatype.ModifyMonitoredItemsResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// SetMonitoringMode sends a SetMonitoringMode request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) SetMonitoringMode(req uatype.SetMonitoringModeRequest, deadline time.Time) (*uatype.SetMonitoringModeResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdSetMonitoringModeRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdSetMonitoringModeResponse_Encoding_DefaultBinary:
		res := &uatype.SetMonitoringModeResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// SetTriggering sends a SetTriggering request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) SetTriggering(req uatype.SetTriggeringRequest, deadline time.Time) (*uatype.SetTriggeringResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdSetTriggeringRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdSetTriggeringResponse_Encoding_DefaultBinary:
		res := &uatype.SetTriggeringResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// DeleteMonitoredItems sends a DeleteMonitoredItems request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) DeleteMonitoredItems(req uatype.DeleteMonitoredItemsRequest, deadline time.Time) (*uatype.DeleteMonitoredItemsResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdDeleteMonitoredItemsRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdDeleteMonitoredItemsResponse_Encoding_DefaultBinary:
		res := &uatype.DeleteMonitoredItemsResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// CreateSubscription sends a CreateSubscription request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) CreateSubscription(req uatype.CreateSubscriptionRequest, deadline time.Time) (*uatype.CreateSubscriptionResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdCreateSubscriptionRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdCreateSubscriptionResponse_Encoding_DefaultBinary:
		res := &uatype.CreateSubscriptionResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// ModifySubscription sends a ModifySubscription request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) ModifySubscription(req uatype.ModifySubscriptionRequest, deadline time.Time) (*uatype.ModifySubscriptionResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdModifySubscriptionRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdModifySubscriptionResponse_Encoding_DefaultBinary:
		res := &uatype.ModifySubscriptionResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// SetPublishingMode sends a SetPublishingMode request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) SetPublishingMode(req uatype.SetPublishingModeRequest, deadline time.Time) (*uatype.SetPublishingModeResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdSetPublishingModeRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdSetPublishingModeResponse_Encoding_DefaultBinary:
		res := &uatype.SetPublishingModeResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// Publish sends a Publish request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) Publish(req uatype.PublishRequest, deadline time.Time) (*uatype.PublishResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdPublishRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdPublishResponse_Encoding_DefaultBinary:
		res := &uatype.PublishResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// Republish sends a Republish request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) Republish(req uatype.RepublishRequest, deadline time.Time) (*uatype.RepublishResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdRepublishRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdRepublishResponse_Encoding_DefaultBinary:
		res := &uatype.RepublishResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// TransferSubscriptions sends a TransferSubscriptions request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) TransferSubscriptions(req uatype.TransferSubscriptionsRequest, deadline time.Time) (*uatype.TransferSubscriptionsResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdTransferSubscriptionsRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdTransferSubscriptionsResponse_Encoding_DefaultBinary:
		res := &uatype.TransferSubscriptionsResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// DeleteSubscriptions sends a DeleteSubscriptions request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) DeleteSubscriptions(req uatype.DeleteSubscriptionsRequest, deadline time.Time) (*uatype.DeleteSubscriptionsResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdDeleteSubscriptionsRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdDeleteSubscriptionsResponse_Encoding_DefaultBinary:
		res := &uatype.DeleteSubscriptionsResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// FindServers sends a FindServers request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) FindServers(req uatype.FindServersRequest, deadline time.Time) (*uatype.FindServersResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdFindServersRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdFindServersResponse_Encoding_DefaultBinary:
		res := &uatype.FindServersResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// FindServersOnNetwork sends a FindServersOnNetwork request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) FindServersOnNetwork(req uatype.FindServersOnNetworkRequest, deadline time.Time) (*uatype.FindServersOnNetworkResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdFindServersOnNetworkRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdFindServersOnNetworkResponse_Encoding_DefaultBinary:
		res := &uatype.FindServersOnNetworkResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// GetEndpoints sends a GetEndpoints request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) GetEndpoints(req uatype.GetEndpointsRequest, deadline time.Time) (*uatype.GetEndpointsResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdGetEndpointsRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdGetEndpointsResponse_Encoding_DefaultBinary:
		res := &uatype.GetEndpointsResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// RegisterServer sends a RegisterServer request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) RegisterServer(req uatype.RegisterServerRequest, deadline time.Time) (*uatype.RegisterServerResponse, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdRegisterServerRequest_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdRegisterServerResponse_Encoding_DefaultBinary:
		res := &uatype.RegisterServerResponse{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}

// RegisterServer2 sends a RegisterServer2 request to the server, and waits for a
// response or timeout. To send and receive with no timeout use the zero time
// as deadline.
func (c *Client) RegisterServer2(req uatype.RegisterServer2Request, deadline time.Time) (*uatype.RegisterServer2Response, error) {
	var buf bytes.Buffer

	if err := binary.NewEncoder(&buf).Encode(req); err != nil {
		return nil, err
	}

	resp, err := c.Channel.Send(transport.Request{
		NodeID: uatype.NewFourByteNodeID(0, uatype.NodeIdRegisterServer2Request_Encoding_DefaultBinary).Expanded(),
		Body:   &buf,
	}, deadline)
	if err != nil {
		return nil, err
	}
	switch resp.NodeID.Uint() {
	case uatype.NodeIdRegisterServer2Response_Encoding_DefaultBinary:
		res := &uatype.RegisterServer2Response{}
		if err := binary.NewDecoder(resp.Body).Decode(res); err != nil {
			return res, err
		}
		return res, nil
	case uatype.NodeIdServiceFault_Encoding_DefaultBinary:
		fault := uatype.ServiceFault{}
		if err := binary.NewDecoder(resp.Body).Decode(&fault); err != nil {
			return nil, err
		}
		return nil, fault
	}
	return nil, fmt.Errorf("Unexpected NodeID: %d %s", resp.NodeID.Uint(), resp.NodeID.DisplayName())
}
